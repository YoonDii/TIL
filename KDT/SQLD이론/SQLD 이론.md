### SQLD이론 1과목

### 1과목 데이터 모델링의 이해

### 1장 데이터 모델링의 이해

#### 1절 데이터 모델의 이해

1. 모델링 : 현실세계를 단순화하여 표현하는 것
   - 특징
     - 추상화: 일정한 형식에 맟춰 표현함
     - 단순화 : 제한된 표기법이나 언어로 표현함
     - 명확성: 이해가 쉽게 표현함
   - 관점
     - 데이터 관점: 업무와 데이터 및 데이터 사이의 관계
     - 프로세스 관점: 진행되고 있거나 진행되어야 하는 업무
     - 상관 관점: 데이터에 대한 업무 처리 방식의 영향
2. 데이터 모델링: 정보 시스템 구축을 위한 데이터 관점의 업무 분석 기법
   - 목적
     - 정보에 대한 표기법을 통일하여 업무 내용 분석 정확도 증대
     - 데이터 모델을 기초로 DB 생성
   - 기능
     - 가시화
     - 명세화
     - 구조화된 틀 제공
     - 문서화
     - 다양한 관점 제공
     - 구체화
   - 중요성
     - 파급효과
     - 간결한 표현 : 정보 요구사항과 한계를 간결하게 표현하는 도구
     - 데이터 품질
       - 유일성 : 데이터 중복 저장 방지
       - 유연서이 데이터 정의와 데이터 사용 프로세스 분리
       - 일관성
   - 이해관계자
     - 개발자
     - DBA
     - 모델러
     - 현업업무전문가 - 완성된 모델을 정확히 해석할 수 있어야함.
3. 데이터 모델링 3단계
   1. 개념적 모델링 : 엔터티와 속성을 도출하고 ERD를 작성함, 업무 중심적이고 포괄적인 수준의 모델링
   2. 논리적 모델링 : 식별자를 도출하고 속성과 관계 등을 정의함, 정규화를 수행하여 데이터 모델의 독립성과 재사용성 확보,  논리 데이터 모델은 데이터 모델링 완료 상태
   3. 물리적 모델링 : DB를 구축함, 성능 및 보안 등 물리적인 성격 고려

⭐️ 프로젝트 생명주기(라이프사이클)

​		계획 > 분석 > 설계 > 개발 > 테스트 > 전환/이행 단계로 구성됨

- 계획 과 분석 단계는 개념적 모델링
- 분석 단계는 논리적 모델링
- 설계 단계는 물리적 모델링에 해당

4. DB의 3단계 구조 : 데이터 독립성 확보를 목표로 함
   - DB 독립성의 필요성 : 데이터의 중복성과 데이터 복잡도 증가로 인한 유지보수 비용 증가/ 요구사항 대응 저하
   - 3단계 스키마
     - 외부스키마 : 각 사용자 단계의 개인적인 DB 스키마, 사용자 관점, 응용 프로그램이 접근하는 DB를 정의함
     - 개념 스키마 : 조직 전체의 통합된 DB 스키마, 설계자 관점 데이터 모델링의 지향점
     - 내부 스키마 : 물리적으로 데이터가 저장되는 방법을 표현하는 스키마, 개발자 관점, 물리적 저장 구조
     - 데이터 독립성
       - 논리적 독립성 : 외부 스키마가 개념 스카마의 변화에 무관함, 논리적 사상 없음
       - 물리적 독립성 : 개념 스키마가 내부 스키마의 변화에 무관함, 물리적 사상 없음
5. 데이터 모델링 3요소 : 엔터티, 관계 , 속성
6. ERD(Enity Relationship Diagram) 
   - 언터티는 사각형
   - 관계는 마름모
   - 속성은 타원형으로 표현, 현실의 데이터 모두 표현 가능
     - 엔터티 도출
     - 엔터티 배치
     - 엔터티 간 관계 설정
     - 관계명 기술
     - 관계차수 표현 :  1:1, 1:N, M:N 
     - 관계선택사양 표현 : 필수, 선택
7. 좋은 모델링의 요건
   - 완전성
   - 중복 배제
   - 업무 규칙
   - 데이터 재사용
   - 의사소통
   - 통합성



####  2절 엔터티 

1. 정의 : 업무에서 관리해야 하는 데이터의 집합, 명사형, 인스턴스의 집합
2. 특징
   - 업무에서 필요로 함
   - 유일한 식별자를 가짐
   - 2개 이상의 인스터스를 포함함
   - 업무 프로세스에 이용됨
   - 속성을 가짐
   - 관계를 가짐
3. 종류
   - 유무형에 따른 분휴
     - 유형 엔터티 : 물리적 형태가 있고 지속적으로 활용되는 엔터티
     - 개념 엔터티 : 물리적 형태가 없는 엔터티
   - 발생시점에 따른 분휴
     - 기본 엔터티 - 독립적으로 생성되는 엔터티
     - 중심 엔터티 - 기본 엔터티와 행위 엔터티의 중간에 존재하는 엔터티
     - 행위 엔터티(사건엔터티) - 2개 이상의 부모 엔터티로부터 발생함, 비즈니스 프로세스를 실행하면서 생성되는 엔터티, 지속적으로 정보가 추가되고 변경되어 데이터양이 가장 많음
4. 명명 규칙
   - 현업업무에서 사용하는 용어
   - 약어 지양
   - 단수 명사
   - 유일성 보장
   - 명확성



#### 3절 속성

1. 정의 : 엔터티가 가지는 최소 의미 단위, 인스턴스의 구성요소
2. 엔터티와 인스턴스 및 속성과 속성값 간의 관계
   - 엔터티 - 인스턴스- 속성- 속성값
3. 속성 표기법 : IE 표기법, Barker 표기법
4. 특징
   - 업무에서 필요하고 관리하고자 하는 정보
   - 주식별자에 함수적으로 종속됨
   - 속성값 하나만 가짐 (하나 이상의 속성값이면 정규화 필요)
5. 종류
   - 특성에 따른 분류
     - 기본 속성 : 비즈니스 프로세스에 서 도출되는 본래의 속성
     - 설계 속성 : 데이터 모델링 과정에서 업무 규칙화를 위해 발생하는 속성
     - 파생 속성 : 다른 속성에 의해 만들어지는 속성 <-> 저장속성은 유도속성을 생성하는 데 사용되는 속성
   - 분해가능 여부에 따른 분류
     - 단일 속성 : 하나의 의미
     - 복합 속성 : 여러 의미, 단일 속성으로 분해 가능.  ex)주소
     - 단일값 속성 : 하나의 값
     - 다중값 속성 : 여러 값, 엔터티로 분해 가능
   - 엔터티 구성방식에 따른 분류
     - 기본키 속성 : 엔터티를 식별할 수 있는 속성
     - 외래키 속성 : 다른 엔터티와의 관계에서 포함된 속성
     - 일반 속성 : 엔터티에 포함되고 PK나 FK속성이 아닌 속성
6. 도메인 : 속성이 가질 수 있는 값의 범위



#### 4절 관계

1. 정의 : 엔터티 간의 논리적인 관련성, 동사형
2. 관계의 페어링 : 인스턴스 간 개별적 관계
3. 관계 표기법 : 관계명 / 관계차수 / 관계선택사양
   - 관계차수 : 관계 내 튜플의 전체 개수, 1은 직선, 다는 삼발로 표시
     - M :N 관계 : 관계형 DB에서 M:N 관계의 조인은 카테시안 곱 발생
   - 관계선택사양 : 필수는 I, 선택은 O로 표시
4. 종류
   - ERD 기준 : 표기구분 안함
     - 존재 관계 : 엔터티 간의 상태
     - 행위 관계 : 엔터티 간에 발생한ㄴ 행위
   - UML (unified modeling language) 기준
     - 연관 관계 : 실선 표기
     - 의존 관계 : 점선 표기
   - 식별자에 따른 분휴
     - 식별 관계 : 부모 엔터티의 식별자를 자식 엔터티에서 주식별자로 사용
       - 약한 엔터티 : 부모 엔터티에 종속되어 존재 <-> 강한 엔터티는 독립적으로 존재
     - 비식별 관계 : 부모 엔터티의 식별자를 자식 엔터티에서 일반 컬럼으로 참조 사용, 약한 종속 관계
       - 식별 관계만으로 연결되면 주식별자 수가 많아질 수밖에 없으므로 관계 강약 분석 / 자식 엔터티의 독립 PK 필요성 / SQL 복잡성과 개발 생산성 고려 필요
5. 관계 읽기 : 각각의/ 하나의 > 기분 엔터티 > 관계차수 > 대상 엔터티 > 관계선택사양 > 관계명



#### 5절 식별자

1. 정의 : 엔터티를 대표할 수 있는 유일성을 만족하는 속성
2. 특징
   - 유일성
   - 최소성
   - 불변성
   - 존재성
3. 종류
   - 대표성 여부에 따른 분휴
     - 주식별자 : 대표성을 만족하는 식별자
     - 보조 식별자 : 유일성과 최소성만 만족하는 식별자. 참조 관계 연결에 사용할 수 없음
   - DB 키의 종류
     - 기본키 (PK) :엔터티를 대표하는 키, 후보키 중 선정됨
     - 후보키 : 유일성과 최소성을 만족하는 키
     - 슈퍼키 : 유일성만 만족하는 키
     - 대체키 : 기본키를 제외한 나머지 후보키
     - 외래키 (FK) : 여러 테이블의 기본 키 필드, 참조 무결성을 확인하기 위해 사용됨 (허용된 데이터 값만 저장하기 위함)
   - 생성 여부에 따른 분휴
     - 내부 식별자 : 자연스럽게 존재하는 식별자 (~ 본질식별자)
     - 외부 식별자 : 다른 엔터티와의 관계를 통해 생성되는 식별자
   - 속성 수에 따른 분류
     - 단일 식별자 : 하나의 속성
     - 복합 식별자 : 여러 속성
   - 대체 여부에 따른 분류
     - 본직 식별자 : 대체될 수 없는 식별자
     - 인조 식별자 : 인위적으로 만들어지는 대체가능한 식별자 (순서번호를 사용하여 생성된 식별자)
       - 후보 식별자 중 주식별자로 선정할 것이 없거나 주식별자가 너무 많은 컬럼으로 구성되어 있을때 사용
4. 주식별자 도출 기준 : 업무에서 자주 이용되는 속성, 이름 명명 지양, 복합 식별자 지양



### 2장 데이터 모델과 성능

#### 1절 성능 데이터 모델링의 개요

1. 성능 데이터 모델링 : DB 성능향상을 위한 사항이 데이터 모델링에 반영되도록 하는 것
2. 수행 시점 ; 분석 / 설계 단계, 성능 데이터 모델링 시점이 늦어질수록 재업무 비용이 증가함
3. 고려 사항 : 정규화 수행 , DB 용량 산정과 트랜잭션 유형 파악을 통한 반정규화 수행, 정규화는 무조건 해야됨



#### 2절 정규화와 성능

1. 정규화 : 데이터 분해과정, 이상현상 제거
   - 정규형(NF) : 정규화로 도출된 데이터 모델이 갖춰야 할 특성
2. 함수적 종속성(FD) : 결정자와 종속자의 관계, 결정자의 값으로 종속자의 값을 알 수 있음.
   - 다치 종속(MVD) : 여러 칼럼이 동일한 결정자의 종속자 일 때
3. 정규화 이론 - 1차 2차 3차 보이스코드 정규화는 함수적 종속성에 근거 / 4차 정규화는 다치 종속을 제거 / 5차 정규화는 조인에 의한 이상현상을 제거하여 정규화를 수행함
   - 1차 정규화 : 속성의 원자성 확보, 다중값 속성을 분리함
   - 2차 정규화 : 부분 함수 종속성 제고, 일부 기본키에만 종속된 속성을 분리함, 기본키가 하나의 칼럼일 때 생략가능
   - 3차 정규화 : 이행 함수 종속성 제거, 서로 종속관계가 있는 일반 속성을 분리함, 주식별자와 관련성이 가낭 낮음
   - 보이스코드 정규화(BCNF) : 후보키가 기본키 속성 중 일부에 함수적 종속일 때 다수의 주식별자를 분리함
   - 4차 정규화, 5차 정규화 : 다치 종속 분리, 결합 종속 분리
4. 정규화와 성능 : 정규화는 입출력 데이터의 양을 줄여 성능을 향상시킴
   - 정규화로 인한 성능 향상 : 입력/수정/삭제 시 성능은 항상 향상됨
     - 유연성 증가 : High Cohesion & Loose Coupling 원칙에 충실해짐
     - 재활용 가능성 증가 : 개념이 세분화됨
     - 데이터 중복 최소화
   - 정규화로 인한 성능 저하 : 조회 시 처리 조건에 따라 성능 저하가 발생할 수도 있음
     - 데이터 조회시 조인을 유발하여 CPU와 메모리를 많이 사용하게 됨
       - 반정규화로 해결 가능
       - 조인이 발생하더라도 인덱스를 사용하여 조인 연산을 수행하면 성능 상 단점이 거의 없고, 정규화를 통해 필요한 인덱스의 수를 줄일 수 있음
       - 정규화를 통해 소량의 테이블이 생성된다면 성능 상 유리할 수 있음



#### 3절 반정규화와 성능

1. 반정규화 : 데이터 중복을 허용하여 조인을 줄이는 DB 성능 향상 방법, 데이터의 무결성을 희생하고 조회 성능 향상

2. 절차

   - 반정규화 대상 조사 : 데이터 처리 범위 및 통계성 등 조사
   - 다른 방법 검토 : 뷰 / 클러스터링 / 인덱스 / 애플리케이션
   - 반정규화 적용 : 정규화 수행 후 반정규화 수행

3. 기법

   - 테이블 반정규화

     - 테이블 병합

       - 1:1 관게 테이블 병합
       - 1:N 관계 테이블 병합 : 많은 데이터 중복 발생
       - 슈퍼타입 / 서브 타입 테이블 병합

     - 테이블 분할 : 수직분할 / 수평분할

     - 테이블 추가

       - 중복 테이블 : 업무나 서버가 다를 때 중복 테이블 생성(원격 조인 제거)
       - 통계 테이블
       - 이력 테이블
       - 부분 테이블 : 자주 이용하는 칼럼으로 구성된 테이블 생성

     - 칼럼 반정규화

       - 줄복 칼럼 추가
       - 파생 칼럼 추가 : 필요한 값 미리 계산한 칼럼 추가
       - 이력 테이블 칼럼 추가
       - PK에 의한 컬럼 추가 : PK의 종속자를 일반속성으로 생성
       - 응용 시스템의 오작동을 위한 칼럼 추가

     - 관계 방정규화 : 데이터 무결성 보장 가능

       - 중복 관계 추가

       

#### 4절 대용향 데이터에 따른 성능

> 테이블 반정규화 중 테이블 분할 관련

1. 블록: 테이블의 데이터 저장 단위
2. 대량 데이터발생으로 인한 현상 : 블록 I/O 횟수 증가 --> 디스크 I/O 가능성 상승 (디스크 I/O 시 성능 저하)
   - 로우 체이닝 : 행 길이가 너무 길어 여러 블록에 걸쳐 저장되는 현상
   - 로우 마이그레이션 : 수정된 데이터가 해당 블록이 아닌 다른 블록의 빈 공간에 저장되는 형상
3. 데이블 분할 : 반정규화 기법
   - 수직분할 : 칼럼 단위로 테이블을 분할하여 I/O를 감소시킴, 너무 많은 수의 칼럼이 있는 경우 사용
   - 수평분할 ; 행 단위로 테이블을 분할하여 I/O를 감소시킴
4. 파티셔닝 : 테이블 수평분할 기법, 논리적으로는 하나의 테이블이지만 물리적으로 여러 데이터 파일에 분산 저장, 데이터 조회 범위를 줄여 성능 향상
   - Range Partition : 데이커 값의 범위를 기준으로 분할
   - List Patrition : 특정한 값을 기준으로 분할
   - HAsh partition : 해시 함수를 적용하여 분할, DBMS가 알아서 분할 관리, 데이터 위치를 알 수 없음
   - Composite Partition : 여러 파티션 기법을 복합적으로 사용하여 분할
   - 파티션 인덱스 
     - Global Index, Local Index : 여러 파티션에서 단일 인덱스 사용, 파티션 별로 각자 인덱스 사용
     - Prefixed Index, Non-Prefixed Index : 파티션키와 인덱스키 동일, 파티션키와 인덱스키 구분



#### 5절 DB 구조와 성능

1. 슈퍼타입/서브타입 데이터 모델 변환을 통한 성능 향상

   - 슈퍼타입/ 서브타입 데이터 모델 : 속성을 할당하여 배치하는 수평 분할된 형태의 모델

     - 공통속성은 슈퍼타입으로 모델링하고 차이가 있는 속성은 서브타입으로 구분됨.
     - 변환을 통해 정확하게 업무를 표현할 수 있고, 물리적 모델링 시 선택의 폭을 넓힐 수 있음.

   - 변환기준 : 데이터 양, 트랜잭션 유형

   - 변환 기술

     - 1:1 타입 : 개별로 처리하는 트랜잭션에 대해 개별 테이블 구성, 슈퍼타입과 서브타입 각각 필요한 속성과 유형에 적합한 데이터만 가지도록 분리하여 1:1 관계를 갖도록 함
     - 슈퍼/서브 타입 : 슈퍼타입과 서브타입을 공통으로 처리하는 트랜잭션에 대해 슈퍼타입과 서브타입 각각의 테이블 구성
     - All in One  타입 : 일관 처리하는 트랜잭션에 대해 단일 테이블 구성


|              |        1:1 타입         |       슈퍼/서브 타입       |       All in One  타입       |
| :----------: | :---------------------: | :------------------------: | :--------------------------: |
|     특징     |    개별 테이블 유지     | 슈퍼/서브 타입 테이블 구성 |       단일 테이블 구성       |
| 트랜잭션유형 |        개별 처리        |  슈퍼/서브 타입 공통 처리  |           일괄처리           |
|    확장성    | 좋음 (테이블 추가 용이) |            보통            |             나쁨             |
|  조인 성능   |  나쁨 (조인 많이 필요)  |   나쁨 (조인 많이 필요)    |             좋음             |
|   I/O 성능   |          좋음           |            좋음            | 나쁨 (항상 전체 데이터 조회) |
|  관리용이성  |          나쁨           |            나쁨            |             좋음             |

2. PK/FK 칼럼 순서 조절을 통한 성능 향상 : 등호 조건이나 BETWEEN 조건이 걸리는 칼럼을 앞으로 이동 (여러 조건이 있을 경우 등호 조건이 걸리는 칼럼을 선두로 이동)
3. 인덱스 특성을 고려한 PK/FK DB성능 향상 : 물리적인 테이블에 FK WPDIRDMF RJFDJ DLSEPRTMFMF TODTJD



#### 6절 분산 DB 데이터에 따른 성능

1.  분산 DB : 분산된 DB를 하나의 가상 시스템으로 사용할 수 있도록 한 DB, 물리적 사이트는 분산되어 있으나 논리적으로 동일한 시스템, 과거에는 위치 중심이었으나 현재는 업무 필요에 따라 분산 설계
   - 설계 방식
     - 상향식 : 지역 스키마 작성 후 전역 스키마 작성
     - 하향식 : 전역 스키마 작성 후 지역사상 스키마 작성
   - 장단점
     - 신뢰성과 가용성 증가 / 빠른 응답 속도와 통신비용 절감 / 용량 확장 용이
     - 관리 및 통제 어려움 / 데이터 무결성 관리 어려움 / S/W개발 비용 및 처리 비용 증가 / 불규칙한 응답 속도
2. 분산 DB의 투명성 `분위지중장병행`
   -  분할 투명성 : 하나의 논리적 관계가 분할되어 각 단편의 사본이 여러 사이트에 저장됨
   - 위치 투명성 : 사용하려는 데이터 저장 장소가 명시되지 않아도 됨
   - 지역사상 투명성 : 지역 DBMS와 물리적 DB 사이의 사상이 보장됨
   - 중복 투명성 : DB 객체 중복 여부를 몰라도 됨
   - 장애 투명성 : 구성요소(DBMS,컴퓨터)의 장애에 무관하게 트랜잭션의 원자성이 유지됨
   - 병행 투명성 : 다수의 트랜잭션을 동시에 수행했을 때 결과의 일관성이 유지됨 /병렬아님
3. 분산 DB 적용 기법
   -  테이블 위치 분산 : 설계된 테이블의 위치를 분산함
   - 테이블 분할 분산 : 테이블을 쪼개서 분산함
     - 수평분할
     - 수직분할
   - 테이블 복제 분산 : 동일한 테이블을 다른 지역이나 서버에서 동시 생성함, 원격지 조인을 내부 조인으로 변경하여 성능 향상
     - 부분 복제 
     - 광역복제
   - 테이블 요약 분산
     - 분석요약 : 사이트 별 요약정보를 본사에서 통합하여 전체 요약정보 산출
     - 통합요약 : 사이트 별 정보를 본사에서 통합하여 전체 요약정보 산출





참조- `https://dataonair.or.kr/db-tech-reference/d-guide/sql/`
